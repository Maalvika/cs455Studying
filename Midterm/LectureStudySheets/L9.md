# Lecture 5 : Thread Safety
## Sharing Objects
#### Terms:
- **Object Publication** - Making an object available outside of the current scope
- **Escaped Object** - An object that has been unintentionally published outside of its current scope

#### Concepts:
- Synchronization and properly sharing objects lays the foundation for writing thread-safe classes
  - A large part of syncrhonization is ensuring that we prevent one thread from modifying and object statue while another thread is using the object
- Publishing an object makes it available outside of the current scope, this can be done one of the following ways:
  - Storing a reference to it
  - Returning it from non-private method
  - Passing it as an argument to another method
- An object is said to have escaped when it was unintentionally published
- The following are dangers associated with publication:
  - Publishing internal state variables makes it difficult to perserve invariants
  - Publishing objects before they are constructed comprimises thread safety 
- The following illustrates one of the most blatant forms of publication, a public static field

![alt-text](https://raw.github.com/jarretflack/cs455Studying/master/Midterm/images/L9-public-static.png?raw=true)

- Now any Secret object that you add to KnownSecrets is published as well (it escaped!)
- The Following illustrates an internal mutable state that escapes

![alt-text](https://raw.github.com/jarretflack/cs455Studying/master/Midterm/images/L9-internal-mutable-state-escape.png?raw=true)

- What was intended to be private can now be mutated by anything that calls getStates(), oh nooo!
- The following illustrates another way to publish an internal state

![alt-text](https://raw.github.com/jarretflack/cs455Studying/master/Midterm/images/L9-published-internal-state.png?raw=true)

- Turns out that when EventListener is published, it publishes the enclosing ThisEscape instance
- You might ask why? Well, inner class instances contain hidden references to enclosing instances!!!
- An object is a predictable consistent state only after its constructor returns
  - So publishing an object with its constructor is publishing a half baked (highly unpredictable) object!!!
  - So don't allow "this" to escape during construction
- Another common mistake is to start a thread from the constructor of an object
  - Almost anytime that a thread is started in a contstructor a reference to "this" is given to the newly started thread
  - You ask why? Remember the conversation about inner clas instances containing hidden references to the enclosing instance? Well most of the time you will be passing an inner class to the started thread, Uh oh!!
  - You can create a thread in a constructor just fine, just don't start it there. Wait for the object to be fully baked!

## Thread Confinement
#### Terms:

#### Concepts:

## Immutable Objects
#### Terms:

#### Concepts:

## Composing Objects
#### Terms:

#### Concepts:

## State Ownership
#### Terms:

#### Concepts:

## Guarding State With Private Locks
#### Terms:

#### Concepts:

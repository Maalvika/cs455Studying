# Lecture 7: Threads
## Data Synchronization
#### Terms:
- **Heisenbugs** - Bugs that disappear or change behavior when you examine them
- **Bohr bugs** - Deterministic, easy to diagnose
- **Race condition** - Threads attempt to access data simultaneously causing undesired behavior
- **Atomic** - Code that cannot be interrupted during its execution; cannot be found in intermediate state
  - Loading and storing variables is an atomic operation in Java, except for `long` and `double` variables
- **Lock scope** - Period between grabbing and releasing a lock
- `synchronized` - Only one thread is able to enter a synchronized block of code at a time
  - Thread that wants to execute method must acquire the object lock
  - When thread has finished execution, it releases the lock
- `volatile` - All load and store operations are atomic and done from main memory
  - Forces JVM to not make temporary copies of a variable
  - Declaring an array `volatile` makes the reference volatile, not each individual element
  - Does not synchronize compound operations (++, --)
#### Concepts:
- There is one lock per object; if two threads call synchronized methods on the same object one must wait for the lock.
  - If two threads call synchronized methods on two different objects, there is no issue
- Race Condition
  - Example: a thread is modifying data while another thread is accessing it
  ![Race condition](https://raw.github.com/jarretflack/cs455Studying/master/Midterm/images/L7-race-condition.png?raw=true)
  - It is possible that `values` and `position` are being changed while they are being used
  - Can be solved using `synchronized` keyword, making the operations atomic
- Issues with synchronization


  ![Lock scope](https://raw.github.com/jarretflack/cs455Studying/master/Midterm/images/L7-lock-scope.png?raw=true)
  - If we synchronized `run()` and `setDone()`, `setDone()` would never execute
    - `run()` is waiting for the `done` flag, but it cannot be set because `setDone()` is waiting for the lock
- Threads are able to hold values of variables in registers
  - When one thread changes the value, another thread may not see the reflected change
  - Two solutions:
    - Providing setters and getters and using `synchronized` keyword
    - Using `volatile` keyword (cleaner solution)

## Synchronized Methods & Locks
#### Terms:
- **Object lock** - Based on a specific instance of an object, not on a particular method or class
  - One thread can execute `A.modifyData()` while another thread executes `B.modifyData()` in parallel: two different locks are involved and there is no need for threads to wait for each other.
- **Class lock** - Object lock of the `Class` object that models the class; only one per class.
  - Allows for synchronization of static methods
#### Concepts:
- Two or more synchronized methods can never run in parallel.
- If two different synchronized methods of the same object are called, they both require the same lock.
- Unsynchronized methods do not require a lock and can be executed at any time by any thread.
- Object locks and class locks can be grabbed/released independently of each other.
- When a non-static synchronized method calls a statis synchronized method, it acquires both locks.

## Explicit Locking
#### Terms:
- **`Lock` interface** - Explicit object representing a lock, similar to a `synchronized` block.
  - `lock()` - called at start of method
  - `unlock()` - called at end of method
#### Concepts:
- `synchronized` keyword serializes access, but it is not suitable for controlling lock scope in certain situations.
  - If we have an object representing the lock, we can easily store it, pass it around, or discard it.
- If another thread owns the lock, the thread attempting to get the lock must wait for that thread to call `unlock()`.
#### Example:


![Explicit Lock](https://raw.github.com/jarretflack/cs455Studying/master/Midterm/images/L7-explicit-locking.png?raw=true)
#### Advantages of explicit locking:
  - Grab and release locks whenver you want
  - Two objects can share the same lock
  - Lock can be attached to data and groups of data instead of objects
  - Can move anywhere to adjust lock scope specific to problem
